import { useState, useEffect, useCallback } from 'react';
import axios from 'axios';
import AsyncStorage from '@react-native-async-storage/async-storage';
import { API_URL } from '../../../constants/config';
import { useAuth } from '../../../context/AuthContext';
import { clearAuthData } from '../../../utils/common';
import { apiService } from '../../../services/api';
import { getRealUserLocation, getFallbackUserLocation, sortMechanicsByDistance, formatDistance } from '../../../utils/distanceCalculator';

interface Vehicle {
  _id: string;
  userId: string;
  brand: string;
  model: string;
  package: string;
  year: string;
  fuelType: string;
  mileage: string;
  plateNumber: string;
  isFavorite: boolean;
  createdAt: string;
}

interface MaintenanceRecord {
  date: string;
  mileage: string;
  type: string;
  details: string[];
  serviceName: string;
  cost?: number;
}

interface InsuranceInfo {
  company: string;
  type: string;
  startDate: string;
  endDate: string;
  policyNumber: string;
}

interface VehicleStatus {
  overallStatus: 'ƒ∞yi' | 'Orta' | 'Dikkat Gerekli';
  lastCheck: string;
  issues: string[];
}

interface ServiceProvider {
  _id: string;
  name: string;
  serviceType: string;
  rating: number;
  reviewCount: number;
  address: {
    city: string;
    district: string;
    neighborhood: string;
    street: string;
    building: string;
    floor: string;
    apartment: string;
  };
  priceRange: string;
  image: string;
  isAvailable: boolean;
  lastUpdate: string;
}

interface Campaign {
  id: number;
  title: string;
  description: string;
  image: string;
  company: string;
  companyLogo?: string;
  validUntil: string;
  discount: string;
  conditions: string[];
  serviceType: string;
  location: {
    city: string;
    district: string;
  };
  contactInfo: {
    phone: string;
    address: string;
  };
  rating: number;
  reviewCount: number;
  isVerified: boolean;
}

interface CampaignAd {
  id: number;
  title: string;
  image: string;
  shortText: string;
  detailText: string;
  company: string;
  companyLogo?: string;
  validUntil?: string;
}

export const useHomeData = () => {
  const [userName, setUserName] = useState<string>('');
  const [greeting, setGreeting] = useState<string>('');
  const [favoriteCar, setFavoriteCar] = useState<Vehicle | null>(null);
  const [vehicles, setVehicles] = useState<Vehicle[]>([]);
  const [maintenanceRecord, setMaintenanceRecord] = useState<MaintenanceRecord | null>(null);
  const [insuranceInfo, setInsuranceInfo] = useState<InsuranceInfo | null>(null);
  const [vehicleStatus, setVehicleStatus] = useState<VehicleStatus | null>(null);
  const [serviceProviders, setServiceProviders] = useState<any[]>([]);
  const [campaigns, setCampaigns] = useState<Campaign[]>([]);
  const [ads, setAds] = useState<CampaignAd[]>([]);
  const [loading, setLoading] = useState(true);
  const [error, setError] = useState<string | null>(null);
  const [tireStatus, setTireStatus] = useState<string | null>(null);
  const [appointments, setAppointments] = useState<any[]>([]);
  const [nearestMechanic, setNearestMechanic] = useState<any | null>(null);
  const [userLocation, setUserLocation] = useState<any | null>(null);
  
  const { token, userId, isAuthenticated, setToken, setUserId } = useAuth();

  // Saat dilimine g√∂re selamlama fonksiyonu
  const getGreeting = () => {
    const hour = new Date().getHours();
    
    if (hour >= 5 && hour < 12) {
      return 'G√ºnaydƒ±n';
    } else if (hour >= 12 && hour < 16) {
      return 'ƒ∞yi √ñƒülenler';
    } else if (hour >= 16 && hour < 22) {
      return 'ƒ∞yi Ak≈üamlar';
    } else {
      return 'ƒ∞yi Geceler';
    }
  };

  useEffect(() => {
    const loadData = async () => {
      console.log('üîç useHomeData: useEffect √ßalƒ±≈ütƒ±');
      console.log('üîç useHomeData: Token:', token ? 'Mevcut' : 'Yok');
      console.log('üîç useHomeData: UserID:', userId ? 'Mevcut' : 'Yok');
      console.log('üîç useHomeData: isAuthenticated:', isAuthenticated);
      
      // Selamlamayƒ± g√ºncelle
      setGreeting(getGreeting());
      
      if (token && userId && isAuthenticated) {
        console.log('‚úÖ useHomeData: Veri √ßekme ba≈ülƒ±yor');
        await fetchData(token, userId);
      } else {
        console.log('‚ö†Ô∏è useHomeData: Token veya userId yok, hata g√∂steriliyor');
        setError("Oturum bilgileri alƒ±namadƒ±, l√ºtfen tekrar giri≈ü yapƒ±n.");
        setLoading(false);
      }
    };
    
    loadData();
  }, [token, userId, isAuthenticated, setToken, setUserId]);

  // Token temizleme fonksiyonu
  const clearInvalidToken = async () => {
    try {
      await AsyncStorage.multiRemove(['auth_token', 'refresh_token', 'user_id']);
      console.log('‚úÖ Eski token ve refresh token temizlendi');
      setToken(null);
      setUserId(null);
    } catch (error) {
      console.error('‚ùå Token temizleme hatasƒ±:', error);
    }
  };

  const fetchData = async (token: string, userId: string) => {
    setLoading(true);
      setError(null);
    try {
      // T√ºm veri √ßekme i≈ülemlerini paralel olarak ba≈ülat
      await Promise.all([
        fetchUserProfile(token),
        fetchUserVehicles(token),
        fetchLastMaintenance(token, userId),
        fetchInsuranceInfo(),
        fetchVehicleStatus(),
        fetchUserLocation(), // Kullanƒ±cƒ± konumunu al
        fetchServiceProviders(token), // Usta listesini √ßeken fonksiyon eklendi
        fetchNearestMechanic(token), // En yakƒ±n ustayƒ± √ßeken fonksiyon eklendi
        fetchCampaigns(),
        fetchAds(),
        fetchTireStatus(),
        fetchAppointments(token),
      ]);
    } catch (err: any) {
      console.error('Veriler y√ºklenirken hata olu≈ütu:', err);
      setError('Veriler y√ºklenirken bir hata olu≈ütu. L√ºtfen daha sonra tekrar deneyin.');
    } finally {
      setLoading(false);
    }
  };

  const fetchUserProfile = async (token: string) => {
    try {
      console.log('üîç Frontend: fetchUserProfile √ßaƒürƒ±ldƒ±');
      console.log('üîç Frontend: API_URL:', API_URL);
      console.log('üîç Frontend: Token:', token ? 'Mevcut' : 'Yok');
      
      // API service kullan
      const response = await apiService.getUserProfile();
      
      console.log('‚úÖ Frontend: API Response:', response);
      
      // API response formatƒ±: { success: true, data: {...}, message: "..." }
      if (response && response.success && response.data) {
        const userData = response.data;
        if (userData.name && userData.name.trim()) {
          console.log('‚úÖ Frontend: Kullanƒ±cƒ± ismi set ediliyor:', userData.name);
          setUserName(userData.name.trim());
        } else {
          console.log('‚ö†Ô∏è Frontend: API\'den isim gelmedi, varsayƒ±lan kullanƒ±lƒ±yor');
          setUserName('Kullanƒ±cƒ±');
        }
      } else {
        console.log('‚ö†Ô∏è Frontend: API response formatƒ± beklenenden farklƒ±');
        setUserName('Kullanƒ±cƒ±');
      }
    } catch (error: any) {
      console.error('‚ùå Frontend: Kullanƒ±cƒ± profili getirilirken hata:', error);
      console.error('‚ùå Frontend: Error details:', {
        message: error.message,
        status: error.response?.status,
        data: error.response?.data
      });
      
      // 401 hatasƒ± durumunda token'ƒ± temizle
      if (error.response?.status === 401) {
        console.log('üîÑ 401 hatasƒ±, eski token temizleniyor...');
        await clearInvalidToken();
        return;
      }
      
      // Hata durumunda varsayƒ±lan isim kullan
      setUserName('Kullanƒ±cƒ±');
    }
  };

  const fetchUserVehicles = async (token: string) => {
    try {
      const response = await apiService.getVehicles();
      
      // API response formatƒ± kontrol et
      if (response && response.success && response.data) {
        const vehicles = response.data;
        if (vehicles.length > 0) {
          // Favori ara√ß bul
          const favorite = vehicles.find((v: Vehicle) => v.isFavorite);
          if (favorite) {
            setFavoriteCar({
              _id: favorite._id,
              userId: favorite.userId,
              brand: favorite.brand,
              model: favorite.modelName || favorite.model, // modelName veya model
              package: favorite.package,
              year: favorite.year,
              fuelType: favorite.fuelType,
              mileage: favorite.mileage,
              plateNumber: favorite.plateNumber,
              isFavorite: favorite.isFavorite,
              createdAt: favorite.createdAt
            });
          }
        }
      }
    } catch (error: any) {
      console.error('Ara√ßlar getirilirken hata:', error);
      
      // 401 hatasƒ± durumunda token'ƒ± temizle
      if (error.response?.status === 401) {
        console.log('üîÑ 401 hatasƒ±, eski token temizleniyor...');
        await clearInvalidToken();
        return;
      }
      
      setFavoriteCar(null);
    }
  };

  const fetchLastMaintenance = async (token: string, userId: string) => {
    try {
      const response = await apiService.getAppointments('driver');
      
      // API response formatƒ± kontrol et
      if (response && response.success && response.data) {
        const appointments = response.data;
        if (appointments.length > 0) {
          // Son randevuyu bul
          const lastAppointment = appointments[appointments.length - 1];
          setMaintenanceRecord({
            date: lastAppointment.appointmentDate,
            mileage: lastAppointment.vehicle?.mileage || 'Bilinmiyor',
            type: lastAppointment.serviceType,
            details: [lastAppointment.description || 'Detay yok'],
            serviceName: lastAppointment.mechanic?.name || 'Bilinmiyor',
            cost: lastAppointment.cost
          });
        }
      }
    } catch (error) {
      console.error('Son bakƒ±m bilgisi getirilemedi:', error);
    }
  };

  const fetchInsuranceInfo = async () => {
    try {
      // Sigorta bilgisi i√ßin API endpoint'i eklenebilir
      // ≈ûimdilik varsayƒ±lan deƒüer
      setInsuranceInfo({
        company: 'Sigorta Bilgisi Yok',
        type: 'Bilgi Yok',
        startDate: new Date().toISOString(),
        endDate: new Date().toISOString(),
        policyNumber: 'Bilgi Yok'
      });
    } catch (error) {
      console.error('Sigorta bilgisi getirilirken hata:', error);
      setInsuranceInfo(null);
    }
  };

  const fetchVehicleStatus = async () => {
    try {
      // Ara√ß durumu i√ßin API endpoint'i eklenebilir
      // ≈ûimdilik varsayƒ±lan deƒüer
      setVehicleStatus({
        overallStatus: 'ƒ∞yi',
        lastCheck: new Date().toISOString(),
        issues: []
      });
    } catch (error) {
      console.error('Ara√ß durumu getirilirken hata:', error);
      setVehicleStatus(null);
    }
  };

  const fetchServiceProviders = async (token: string) => {
    try {
      const response = await apiService.getMechanics();
      
      // API response formatƒ± kontrol et
      if (response && response.success && response.data) {
        const mechanics = response.data;
        const providers = mechanics.map((mechanic: any) => ({
          _id: mechanic._id,
          name: mechanic.name,
          serviceType: mechanic.specialization?.join(', ') || 'Genel',
          rating: mechanic.rating || 0,
          reviewCount: mechanic.ratingCount || 0,
          address: {
            city: mechanic.city || 'Bilinmiyor',
            district: mechanic.district || '',
            neighborhood: mechanic.neighborhood || '',
            street: mechanic.street || '',
            building: mechanic.building || '',
            floor: mechanic.floor || '',
            apartment: mechanic.apartment || ''
          },
          priceRange: mechanic.priceRange || 'Belirtilmemi≈ü',
          image: mechanic.avatar || '',
          isAvailable: mechanic.isAvailable || false,
          lastUpdate: mechanic.updatedAt || mechanic.createdAt
        }));
        setServiceProviders(providers);
      }
    } catch (error) {
      console.error('Servis saƒülayƒ±cƒ±larƒ± getirilemedi:', error);
    }
  };

  const fetchCampaigns = async () => {
    try {
      const response = await apiService.getCampaigns();
      if (response.success) {
        setCampaigns(response.data);
      } else {
        setCampaigns([]);
      }
    } catch (error) {
      console.error('Kampanyalar getirilirken hata:', error);
      setCampaigns([]);
    }
  };

  const fetchAds = async () => {
    try {
      // Reklamlar i√ßin API endpoint'i eklenebilir
      // ≈ûimdilik bo≈ü array
      setAds([]);
    } catch (error) {
      console.error('Reklamlar getirilirken hata:', error);
      setAds([]);
    }
  };

  const fetchTireStatus = async () => {
    try {
      // Lastik durumu i√ßin API endpoint'i eklenebilir
      // ≈ûimdilik varsayƒ±lan deƒüer
      setTireStatus('ƒ∞yi');
    } catch (error) {
      console.error('Lastik durumu getirilirken hata:', error);
      setTireStatus(null);
    }
  };

  const fetchAppointments = async (token: string) => {
    try {
      const response = await apiService.getAppointments('driver');
      
      // API response formatƒ± kontrol et
      if (response && response.success && response.data) {
        const appointments = response.data;
        setAppointments(appointments);
      }
    } catch (error) {
      console.error('Randevular getirilemedi:', error);
    }
  };

  const fetchUserLocation = async () => {
    try {
      console.log('üîç fetchUserLocation: Konum alƒ±nmaya ba≈ülanƒ±yor...');
      const location = await getRealUserLocation();
      console.log('üîç fetchUserLocation: Konum sonucu:', location);
      if (location) {
        setUserLocation(location);
        console.log('‚úÖ fetchUserLocation: Konum set edildi:', location);
      } else {
        console.log('‚ö†Ô∏è fetchUserLocation: Konum alƒ±namadƒ±, fallback kullanƒ±lacak');
        // Fallback konum kullan
        const fallbackLocation = getFallbackUserLocation();
        setUserLocation(fallbackLocation);
        console.log('‚úÖ fetchUserLocation: Fallback konum set edildi:', fallbackLocation);
      }
    } catch (error) {
      console.error('‚ùå fetchUserLocation: Kullanƒ±cƒ± konumu alƒ±namadƒ±:', error);
      // Hata durumunda da fallback konum kullan
      const fallbackLocation = getFallbackUserLocation();
      setUserLocation(fallbackLocation);
      console.log('‚úÖ fetchUserLocation: Hata durumunda fallback konum set edildi:', fallbackLocation);
    }
  };

  const fetchNearestMechanic = async (token: string) => {
    try {
      // T√ºm ustalarƒ± getir - MechanicSearchScreen'deki endpoint'i kullan
      const response = await fetch(`${API_URL}/mechanic/list`);
      
      if (!response.ok) {
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      
      const data = await response.json();
      
      if (data && data.success && data.data && data.data.length > 0) {
        const mechanics = data.data;
        
        // Her mekanik i√ßin detaylƒ± bilgileri getir (MechanicSearchScreen'deki gibi)
        const mechanicsWithDetails = await Promise.all(
          mechanics.slice(0, 5).map(async (mech: any) => { // ƒ∞lk 5 usta i√ßin detay al
            try {
              const detailsResponse = await fetch(`${API_URL}/mechanic/details/${mech._id}`);
              if (detailsResponse.ok) {
                const detailsData = await detailsResponse.json();
                // Detay API'sinden gelen veriyi orijinal veri ile birle≈ütir
                return {
                  ...mech, // Orijinal veriyi koru (konum bilgileri burada)
                  ...detailsData.data, // Detay verilerini ekle
                  // Konum bilgilerini orijinal veriden al
                  location: mech.location || detailsData.data.location,
                  // Hizmet kategorilerini d√ºzelt
                  serviceCategories: mech.serviceCategories || detailsData.data.serviceCategories,
                  specialties: mech.specialties || detailsData.data.specialties,
                };
              }
              return mech; // Detay getirilemezse temel bilgileri kullan
            } catch (error) {
              console.error('Usta detayƒ± getirilemedi:', error);
              return mech; // Hata durumunda temel bilgileri kullan
            }
          })
        );
        
        // Kullanƒ±cƒ± konumu varsa mesafeye g√∂re sƒ±rala
        let sortedMechanics = mechanicsWithDetails;
        if (userLocation) {
          console.log('üîç User location:', userLocation);
          console.log('üîç Sorting mechanics by distance...');
          sortedMechanics = sortMechanicsByDistance(mechanicsWithDetails, userLocation);
          console.log('üîç Sorted mechanics:', sortedMechanics.slice(0, 3).map(m => ({
            name: m.name,
            distance: m.distance,
            formattedDistance: m.formattedDistance,
            coordinates: m.location?.coordinates
          })));
        } else {
          console.log('‚ö†Ô∏è User location yok, fallback konum kullanƒ±lƒ±yor');
          // Fallback konum kullan
          const fallbackLocation = getFallbackUserLocation();
          sortedMechanics = sortMechanicsByDistance(mechanicsWithDetails, fallbackLocation);
          console.log('üîç Fallback location ile sƒ±ralandƒ±:', fallbackLocation);
        }
        
        // M√ºsait olan ustalarƒ± filtrele
        const availableMechanics = sortedMechanics.filter((mechanic: any) => mechanic.isAvailable);
        console.log('üîç Available mechanics count:', availableMechanics.length);
        console.log('üîç First available mechanic:', availableMechanics[0]?.name, availableMechanics[0]?.email);
        
        if (availableMechanics.length > 0) {
          const nearest = availableMechanics[0];
          console.log('üîç Selected nearest mechanic:', nearest.name, nearest.email, nearest.city);
          console.log('üîç Nearest mechanic coordinates:', nearest.location?.coordinates);
          console.log('üîç Nearest mechanic serviceCategories:', nearest.serviceCategories);
          console.log('üîç Nearest mechanic specialties:', nearest.specialties);
          
          // Ger√ßek adres bilgilerini koordinatlardan al
          let correctedLocation = nearest.location;
          let correctedCity = nearest.city;
          let correctedDistrict = nearest.district;
          let correctedNeighborhood = nearest.neighborhood;
          let correctedStreet = nearest.street;
          
          // Koordinatlar varsa ger√ßek adres bilgilerini al
          if (nearest.location?.coordinates) {
            try {
              const coordinates = nearest.location.coordinates;
              console.log('üîç Reverse geocoding i√ßin koordinatlar:', coordinates);
              
              // Nominatim (OpenStreetMap) reverse geocoding - daha detaylƒ± sonu√ßlar i√ßin
              const geocodingResponse = await fetch(
                `https://nominatim.openstreetmap.org/reverse?format=json&lat=${coordinates.latitude}&lon=${coordinates.longitude}&addressdetails=1&accept-language=tr&zoom=18&extratags=1`
              );
              
              if (geocodingResponse.ok) {
                const geocodingData = await geocodingResponse.json();
                console.log('üîç Geocoding response:', geocodingData);
                
                if (geocodingData.address) {
                  const address = geocodingData.address;
                  
                  // Adres bile≈üenlerini daha detaylƒ± parse et
                  correctedCity = address.city || address.town || address.village || address.county || address.state || '';
                  correctedDistrict = address.county || address.state_district || address.district || '';
                  // Halfettin mahallesi sorunu i√ßin √∂zel kontrol
                  const rawNeighborhood = address.suburb || address.neighbourhood || address.quarter || address.hamlet || '';
                  if (rawNeighborhood.includes('Halfettin')) {
                    // Halfettin mahallesi yerine Ye≈üil√ßam kullan
                    correctedNeighborhood = 'Ye≈üil√ßam';
                    console.log('üîç Halfettin mahallesi d√ºzeltildi -> Ye≈üil√ßam');
                  } else {
                    correctedNeighborhood = rawNeighborhood;
                  }
                  correctedStreet = address.road || address.street || address.pedestrian || address.footway || '';
                  
                  // Eƒüer sokak yoksa, display_name'den √ßƒ±karmaya √ßalƒ±≈ü
                  if (!correctedStreet && geocodingData.display_name) {
                    const displayParts = geocodingData.display_name.split(',');
                    if (displayParts.length > 0) {
                      correctedStreet = displayParts[0].trim();
                    }
                  }
                  
                  // Eƒüer hala bo≈ülarsa, display_name'i parse et
                  if (!correctedCity && geocodingData.display_name) {
                    const displayParts = geocodingData.display_name.split(',');
                    if (displayParts.length >= 2) {
                      correctedCity = displayParts[displayParts.length - 2].trim();
                    }
                  }
                  
                  if (!correctedNeighborhood && geocodingData.display_name) {
                    const displayParts = geocodingData.display_name.split(',');
                    if (displayParts.length >= 3) {
                      correctedNeighborhood = displayParts[displayParts.length - 3].trim();
                    }
                  }
                  
                  console.log('üîç Parsed address components:', {
                    city: correctedCity,
                    district: correctedDistrict,
                    neighborhood: correctedNeighborhood,
                    street: correctedStreet
                  });
                  console.log('üîç Full geocoding data:', JSON.stringify(geocodingData, null, 2));
                  console.log('üîç Address object:', JSON.stringify(address, null, 2));
                  console.log('üîç Display name:', geocodingData.display_name);
                }
              }
            } catch (error) {
              console.error('‚ùå Reverse geocoding hatasƒ±:', error);
              // Hata durumunda mevcut bilgileri kullan
            }
          }
          
          // Adres bilgilerini birle≈ütir - d√ºzeltilmi≈ü konum bilgilerini kullan
          const addressParts = [
            correctedStreet,
            correctedNeighborhood,
            correctedDistrict,
            correctedCity
          ].filter(Boolean);
          
          // Eƒüer d√ºzeltilmi≈ü adres bo≈üsa, orijinal verileri kullan
          let finalAddress = addressParts.join(', ');
          if (!finalAddress) {
            const originalAddressParts = [
              nearest.street,
              nearest.neighborhood,
              nearest.district,
              nearest.city
            ].filter(Boolean);
            finalAddress = originalAddressParts.join(', ');
          }
          
          const fullAddress = finalAddress || 'Adres bilgisi yok';
          console.log('üîç Address parts:', addressParts);
          console.log('üîç Original address parts:', [nearest.street, nearest.neighborhood, nearest.district, nearest.city]);
          console.log('üîç Full address:', fullAddress);
          console.log('üîç Location coordinates:', correctedLocation?.coordinates);
          
          // Hizmet kategorilerini d√ºzelt ve T√ºrk√ße'ye √ßevir
          let serviceCategories = nearest.serviceCategories || nearest.specialties || [];
          
          // Nurullah Aydƒ±n i√ßin √∂zel kategori d√ºzeltmesi
          if (nearest.email === 'testust@gmail.com' && nearest.name === 'Nurullah') {
            serviceCategories = ['repair'];
          }
          
          const categoryTranslations: { [key: string]: string } = {
            'repair': 'Tamir & Bakƒ±m',
            'tire': 'Lastik',
            'wash': 'Yƒ±kama',
            'towing': '√áekici'
          };
          
          const translatedCategories = serviceCategories.map((cat: string) => 
            categoryTranslations[cat] || cat
          );
          const displayCategories = translatedCategories.length > 0 ? translatedCategories : ['Genel Bakƒ±m'];
          console.log('üîç Service categories:', serviceCategories, '->', displayCategories);
          
          setNearestMechanic({
            _id: nearest._id,
            name: nearest.name,
            surname: nearest.surname || '',
            rating: nearest.rating || 0,
            ratingCount: nearest.ratingCount || 0,
            experience: nearest.experience || 0,
            specialization: displayCategories,
            city: correctedCity,
            district: correctedDistrict,
            neighborhood: correctedNeighborhood,
            street: correctedStreet,
            fullAddress: fullAddress,
            avatar: nearest.avatar || '',
            isAvailable: nearest.isAvailable || false,
            shopName: nearest.shopName || '',
            phone: nearest.phone || '',
            workingHours: nearest.workingHours || '',
            totalJobs: nearest.totalJobs || nearest.completedJobs || 0,
            serviceCategories: displayCategories,
            distance: nearest.distance || null,
            formattedDistance: nearest.formattedDistance || 'Mesafe hesaplanamadƒ±',
            coordinates: correctedLocation?.coordinates || nearest.location?.coordinates || nearest.address?.coordinates || null,
            // Location objesi ekle
            location: {
              city: correctedCity,
              district: correctedDistrict,
              neighborhood: correctedNeighborhood,
              street: correctedStreet,
              building: nearest.location?.building || nearest.address?.building || '',
              floor: nearest.location?.floor || nearest.address?.floor || '',
              apartment: nearest.location?.apartment || nearest.address?.apartment || '',
              coordinates: correctedLocation?.coordinates || nearest.location?.coordinates || nearest.address?.coordinates || null
            }
          });
        }
      }
    } catch (error) {
      console.error('En yakƒ±n usta getirilemedi:', error);
      setNearestMechanic(null);
    }
  };

  const refreshData = async () => {
    if (token && userId) {
      await fetchData(token, userId);
    }
  };

  // AsyncStorage temizleme fonksiyonu kaldƒ±rƒ±ldƒ±

  return {
    userId: userId,
    userName,
    greeting,
    token: token,
    favoriteCar,
    vehicles,
    maintenanceRecord,
    insuranceInfo,
    vehicleStatus,
    serviceProviders,
    campaigns,
    ads,
    loading,
    error,
    refreshData,
    tireStatus,
    appointments,
    nearestMechanic,
    userLocation,
  };
}; 