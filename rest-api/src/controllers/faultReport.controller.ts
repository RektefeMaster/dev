import { Request, Response } from 'express';
import mongoose from 'mongoose';
import { FaultReport } from '../models/FaultReport';
import { Vehicle } from '../models/Vehicle';
import { Mechanic } from '../models/Mechanic';
import { User } from '../models/User';
import { Appointment } from '../models/Appointment';
import { sendNotificationToUser } from '../utils/socketNotifications';
import { validateFaultReport, validateQuote, validateSelectQuote, validateMechanicResponse, validateTomorrowResponse, validateContact } from '../validators/faultReport.validation';
import { TefePointService } from '../services/tefePoint.service';
import { 
  getFaultReportServiceCategory,
  getCategoryQueryValues 
} from '../utils/serviceCategoryHelper';
import { FAULT_CATEGORY_TO_SERVICE_CATEGORY } from '../../../shared/types/enums';

// ArÄ±za bildirimi oluÅŸtur
export const createFaultReport = async (req: Request, res: Response) => {
  try {
    // Validation geÃ§ici olarak devre dÄ±ÅŸÄ±
    // const { error } = validateFaultReport(req.body);
    // if (error) {
    //   return res.status(400).json({
    //     success: false,
    //     message: error.details[0].message
    //   });
    // }

    const {
      vehicleId,
      serviceCategory,
      mainServiceCategory,
      faultDescription,
      photos = [],
      videos = [],
      priority = 'medium',
      location
    } = req.body;

    // Frontend'den gelen ServiceType kod deÄŸerlerini Fault Report TÃ¼rkÃ§e kategorilerine Ã§evir
    // Not: Fault Report model'i TÃ¼rkÃ§e kategori isimleri kullanÄ±yor
    const categoryNameMapping: { [key: string]: string } = {
      'genel-bakim': 'Genel BakÄ±m',
      'agir-bakim': 'AÄŸÄ±r BakÄ±m',
      'alt-takim': 'Alt TakÄ±m',
      'ust-takim': 'Ãœst TakÄ±m',
      'kaporta-boya': 'Kaporta/Boya',
      'elektrik-elektronik': 'Elektrik-Elektronik',
      'yedek-parca': 'Yedek ParÃ§a',
      'egzoz-emisyon': 'Egzoz & Emisyon',
      'arac-yikama': 'AraÃ§ YÄ±kama',
      'lastik': 'Lastik',
      'wash': 'AraÃ§ YÄ±kama',
      'towing': 'Ã‡ekici',
      'repair': 'Genel BakÄ±m',
      'tire': 'Lastik',
      // Frontend'teki static kategoriler
      'Genel BakÄ±m': 'Genel BakÄ±m',
      'AÄŸÄ±r BakÄ±m': 'AÄŸÄ±r BakÄ±m',
      'Ãœst TakÄ±m': 'Ãœst TakÄ±m',
      'Alt TakÄ±m': 'Alt TakÄ±m',
      'Kaporta/Boya': 'Kaporta/Boya',
      'Elektrik-Elektronik': 'Elektrik-Elektronik',
      'Yedek ParÃ§a': 'Yedek ParÃ§a',
      'Lastik': 'Lastik',
      'Egzoz & Emisyon': 'Egzoz & Emisyon',
      'AraÃ§ YÄ±kama': 'AraÃ§ YÄ±kama'
    };

    const normalizedServiceCategory = categoryNameMapping[serviceCategory] || serviceCategory;

    const userId = req.user?.userId;

    // AraÃ§ kontrolÃ¼
    const vehicle = await Vehicle.findOne({ _id: vehicleId, userId });
    if (!vehicle) {
      return res.status(404).json({
        success: false,
        message: 'AraÃ§ bulunamadÄ±'
      });
    }

    // Konum bilgisini kontrol et - sadece Ã§ekici hizmeti iÃ§in zorunlu
    let locationData = null;
    
    // Ã‡ekici hizmeti iÃ§in konum zorunlu
    const isLocationRequired = normalizedServiceCategory === 'Ã‡ekici';
    
    if (location && location.coordinates && Array.isArray(location.coordinates) && location.coordinates.length === 2) {
      locationData = {
        type: 'Point',
        coordinates: location.coordinates, // [longitude, latitude]
        address: location.address || '',
        city: location.city || ''
      };
    } else if (isLocationRequired) {
      return res.status(400).json({
        success: false,
        message: 'Ã‡ekici hizmeti iÃ§in konum bilgisi gereklidir'
      });
    }
    
    const faultReport = new FaultReport({
      userId,
      vehicleId,
      serviceCategory: normalizedServiceCategory,
      faultDescription,
      photos,
      videos,
      priority,
      location: locationData, // Sadece Ã§ekici hizmeti iÃ§in
      status: 'pending'
    });

    await faultReport.save();

    // KullanÄ±cÄ± bilgilerini al
    const user = await User.findById(userId).select('name surname phone');
    if (!user) {
      return res.status(404).json({
        success: false,
        message: 'KullanÄ±cÄ± bulunamadÄ±'
      });
    }

    // Ã‡evredeki uygun ustalarÄ± bul
    const nearbyMechanics = await findNearbyMechanics(
      null, // coordinates kaldÄ±rÄ±ldÄ±
      normalizedServiceCategory,
      vehicle.brand,
      null // userCity kaldÄ±rÄ±ldÄ±
    );

    // Her ustaya bildirim gÃ¶nder
    for (const mechanic of nearbyMechanics) {
      try {
        // Usta bilgilerini al (hem Mechanic hem User tablosundan)
        let mechanicData = await Mechanic.findById(mechanic._id).select('name surname phone pushToken');
        if (!mechanicData) {
          // User tablosundan da kontrol et
          mechanicData = await User.findById(mechanic._id).select('name surname phone pushToken');
        }

        if (mechanicData) {
          // Bildirim oluÅŸtur
          const notification = {
            type: 'fault_report',
            title: 'Yeni ArÄ±za Bildirimi',
            message: `${user.name} ${user.surname} aracÄ±nda ${serviceCategory} arÄ±zasÄ± bildirdi`,
            data: {
              faultReportId: faultReport._id,
              vehicleBrand: vehicle.brand,
              vehicleModel: vehicle.modelName,
              serviceCategory,
              faultDescription,
              photos,
              videos,
              userPhone: user.phone,
              userName: `${user.name} ${user.surname}`
            }
          };

          // Real-time bildirim gÃ¶nder (Socket.io)
          sendNotificationToUser(mechanic._id.toString(), notification);
          
          // Push notification gÃ¶nder
          if (mechanicData.pushToken) {
            const { sendPushNotification } = await import('../utils/notifications');
            await sendPushNotification(
              mechanic._id.toString(),
              notification.title,
              notification.message,
              notification.data
            );
          }

          // VeritabanÄ±na bildirim kaydÄ± oluÅŸtur
          const { sendNotification } = await import('../utils/notifications');
          await sendNotification(
            new mongoose.Types.ObjectId(mechanic._id.toString()),
            'mechanic',
            notification.title,
            notification.message,
            'system',
            notification.data
          );

          } else {
          }
      } catch (error) {
        }
    }

    res.status(201).json({
      success: true,
      message: 'ArÄ±za bildirimi baÅŸarÄ±yla oluÅŸturuldu',
      data: {
        faultReportId: faultReport._id,
        status: faultReport.status,
        quotesCount: 0
      }
    });

  } catch (error) {
    console.error('FaultReport creation error:', error);
    console.error('Error details:', {
      message: error.message,
      stack: error.stack,
      name: error.name
    });
    res.status(500).json({
      success: false,
      message: 'ArÄ±za bildirimi oluÅŸturulurken bir hata oluÅŸtu',
      error: process.env.NODE_ENV === 'development' ? error.message : undefined
    });
  }
};

// KullanÄ±cÄ±nÄ±n arÄ±za bildirimlerini getir
export const getUserFaultReports = async (req: Request, res: Response) => {
  try {
    const userId = req.user?.userId;
    const { status, page = 1, limit = 10 } = req.query;

    const query: any = { userId };
    if (status) {
      query.status = status;
    }

    const faultReports = await FaultReport.find(query)
      .populate('vehicleId', 'brand modelName plateNumber year')
      .populate('quotes.mechanicId', 'name surname shopName phone')
      .populate('selectedQuote.mechanicId', 'name surname shopName phone')
      .sort({ createdAt: -1 })
      .limit(Number(limit) * 1)
      .skip((Number(page) - 1) * Number(limit))
      .lean(); // ðŸš€ OPTIMIZE: Memory optimization

    const total = await FaultReport.countDocuments(query);

    res.json({
      success: true,
      data: faultReports,
      pagination: {
        current: Number(page),
        pages: Math.ceil(total / Number(limit)),
        total
      }
    });

  } catch (error) {
    res.status(500).json({
      success: false,
      message: 'ArÄ±za bildirimleri getirilirken bir hata oluÅŸtu'
    });
  }
};

// ArÄ±za bildirimi detayÄ±nÄ± getir
export const getFaultReportById = async (req: Request, res: Response) => {
  try {
    const { id } = req.params;
    const userId = req.user?.userId;

    const faultReport = await FaultReport.findOne({ _id: id, userId })
      .populate('vehicleId', 'brand modelName plateNumber year color')
      .populate('quotes.mechanicId', 'name surname shopName phone rating experience')
      .populate('selectedQuote.mechanicId', 'name surname shopName phone rating experience')
      .populate('appointmentId')
      .lean(); // ðŸš€ OPTIMIZE: Memory optimization

    if (!faultReport) {
      return res.status(404).json({
        success: false,
        message: 'ArÄ±za bildirimi bulunamadÄ±'
      });
    }

    res.json({
      success: true,
      data: faultReport
    });

  } catch (error) {
    res.status(500).json({
      success: false,
      message: 'ArÄ±za bildirimi detayÄ± getirilirken bir hata oluÅŸtu'
    });
  }
};

// Usta iÃ§in arÄ±za bildirimi detayÄ±nÄ± getir
export const getMechanicFaultReportById = async (req: Request, res: Response) => {
  try {
    const { id } = req.params;
    const mechanicId = req.user?.userId;

    const faultReport = await FaultReport.findById(id)
      .populate('userId', 'name surname phone')
      .populate('vehicleId', 'brand modelName plateNumber year color engineType transmissionType fuelType engineSize mileage vehicleCondition')
      .populate('quotes.mechanicId', 'name surname shopName phone rating experience')
      .populate('selectedQuote.mechanicId', 'name surname shopName phone rating experience')
      .populate('appointmentId');

    if (!faultReport) {
      return res.status(404).json({
        success: false,
        message: 'ArÄ±za bildirimi bulunamadÄ±'
      });
    }

    // Usta iÃ§in teklif detaylarÄ±nÄ± gizle
    const faultReportData = faultReport.toObject();
    
    // Tekliflerde sadece fiyat ve tarih gÃ¶ster, diÄŸer detaylarÄ± gizle
    if (faultReportData.quotes) {
      faultReportData.quotes = faultReportData.quotes.map((quote: any) => ({
        ...quote,
        mechanicName: 'Usta',
        mechanicPhone: '***',
        estimatedDuration: '***',
        notes: '***'
      }));
    }

    res.json({
      success: true,
      data: faultReportData
    });

  } catch (error) {
    res.status(500).json({
      success: false,
      message: 'ArÄ±za bildirimi detayÄ± getirilirken bir hata oluÅŸtu'
    });
  }
};

// Usta yanÄ±tÄ± ver (teklif, mÃ¼sait deÄŸilim, yarÄ±n bakarÄ±m, iletiÅŸime geÃ§)
export const submitMechanicResponse = async (req: Request, res: Response) => {
  try {
    const { id } = req.params; // URL'den faultReportId al
    const { responseType, message } = req.body;
    const mechanicId = req.user?.userId;

    // Validation
    const { error } = validateMechanicResponse(req.body);
    if (error) {
      return res.status(400).json({
        success: false,
        message: error.details[0].message
      });
    }

    // Usta kontrolÃ¼
    let mechanic = await Mechanic.findById(mechanicId);
    let userMechanic = null;
    
    if (!mechanic) {
      userMechanic = await User.findById(mechanicId);
      if (!userMechanic || userMechanic.userType !== 'mechanic') {
        return res.status(404).json({
          success: false,
          message: 'Usta bulunamadÄ±'
        });
      }
    }

    // ArÄ±za bildirimi kontrolÃ¼
    const faultReport = await FaultReport.findById(id);
    if (!faultReport) {
      return res.status(404).json({
        success: false,
        message: 'ArÄ±za bildirimi bulunamadÄ±'
      });
    }

    // Zaten yanÄ±t verilmiÅŸ mi kontrol et
    const existingResponse = faultReport.mechanicResponses.find(
      response => response.mechanicId.toString() === mechanicId
    );

    if (existingResponse) {
      return res.status(400).json({
        success: false,
        message: 'Bu arÄ±za iÃ§in zaten yanÄ±t verdiniz',
        data: {
          existingResponse: {
            responseType: existingResponse.responseType,
            message: existingResponse.message,
            createdAt: existingResponse.createdAt
          }
        }
      });
    }

    // YanÄ±t ekle
    faultReport.mechanicResponses.push({
      mechanicId: mechanicId as any,
      responseType,
      message: message || '',
      createdAt: new Date()
    });

    // EÄŸer teklif veriyorsa, quotes array'ine de ekle ve status'u quoted yap
    if (responseType === 'quote') {
      const mechanicName = mechanic ? `${mechanic.name} ${mechanic.surname}` : `${userMechanic?.name} ${userMechanic?.surname}`;
      const mechanicPhone = mechanic ? mechanic.phone : userMechanic?.phone || '';
      
      faultReport.quotes.push({
        mechanicId: mechanicId as any,
        mechanicName: mechanicName || 'Bilinmeyen Usta',
        mechanicPhone: mechanicPhone || '',
        quoteAmount: req.body.quoteAmount || 0,
        estimatedDuration: req.body.estimatedDuration || '',
        notes: message || '',
        status: 'pending',
        createdAt: new Date()
      });
      
      faultReport.status = 'quoted';
    }

    await faultReport.save();

    // KullanÄ±cÄ±ya bildirim gÃ¶nder
    const mechanicName = mechanic ? `${mechanic.name} ${mechanic.surname}` : `${userMechanic?.name} ${userMechanic?.surname}`;
    
    let notificationMessage = '';
    switch (responseType) {
      case 'quote':
        notificationMessage = `${mechanicName} Usta teklif verdi`;
        break;
      case 'not_available':
        notificationMessage = `${mechanicName} Usta ÅŸu anda mÃ¼sait deÄŸil`;
        break;
      case 'check_tomorrow':
        notificationMessage = `${mechanicName} Usta yarÄ±n bakacaÄŸÄ±nÄ± belirtti`;
        break;
      case 'contact_me':
        notificationMessage = `${mechanicName} Usta iletiÅŸime geÃ§menizi istedi`;
        break;
    }

    if (notificationMessage) {
      const notification = {
        type: 'mechanic_response',
        title: 'Usta YanÄ±tÄ±',
        message: notificationMessage,
        data: {
          faultReportId: faultReport._id,
          mechanicName,
          responseType,
          message
        }
      };

      sendNotificationToUser(faultReport.userId.toString(), notification);
    }

    // EÄŸer "yarÄ±n bakarÄ±m" seÃ§ildiyse, kullanÄ±cÄ±ya Ã¶zel bildirim gÃ¶nder
    if (responseType === 'check_tomorrow') {
      const tomorrowNotification = {
        type: 'tomorrow_appointment_request',
        title: 'YarÄ±n Randevu Talebi',
        message: `${mechanicName} Usta yarÄ±n bakacaÄŸÄ±nÄ± belirtti. Randevu oluÅŸturmak ister misiniz?`,
        data: {
          faultReportId: faultReport._id,
          mechanicId: mechanicId,
          mechanicName,
          responseType: 'check_tomorrow',
          message,
          requiresAction: true
        }
      };

      sendNotificationToUser(faultReport.userId.toString(), tomorrowNotification);
    }

    res.json({
      success: true,
      message: 'YanÄ±t baÅŸarÄ±yla gÃ¶nderildi',
      data: {
        responseType,
        message
      }
    });

  } catch (error) {
    res.status(500).json({
      success: false,
      message: 'YanÄ±t gÃ¶nderilirken bir hata oluÅŸtu'
    });
  }
};

// YarÄ±n bakarÄ±m yanÄ±tÄ±nÄ± onayla/reddet
export const handleTomorrowResponse = async (req: Request, res: Response) => {
  try {
    const { id } = req.params; // faultReportId
    const { action } = req.body; // 'accept' veya 'reject'
    const userId = req.user?.userId;

    // Validation
    const { error } = validateTomorrowResponse(req.body);
    if (error) {
      return res.status(400).json({
        success: false,
        message: error.details[0].message
      });
    }

    // ArÄ±za bildirimi kontrolÃ¼
    const faultReport = await FaultReport.findById(id);
    if (!faultReport) {
      return res.status(404).json({
        success: false,
        message: 'ArÄ±za bildirimi bulunamadÄ±'
      });
    }

    // KullanÄ±cÄ± kontrolÃ¼
    if (faultReport.userId.toString() !== userId) {
      return res.status(403).json({
        success: false,
        message: 'Bu arÄ±za bildirimi size ait deÄŸil'
      });
    }

    // "YarÄ±n bakarÄ±m" yanÄ±tÄ±nÄ± bul
    const tomorrowResponse = faultReport.mechanicResponses.find(
      response => response.responseType === 'check_tomorrow'
    );

    if (!tomorrowResponse) {
      return res.status(404).json({
        success: false,
        message: 'YarÄ±n bakarÄ±m yanÄ±tÄ± bulunamadÄ±'
      });
    }

    if (action === 'accept') {
      // KullanÄ±cÄ± onayladÄ± - randevu oluÅŸturma iÃ§in gerekli bilgileri dÃ¶ndÃ¼r
      const mechanic = await User.findById(tomorrowResponse.mechanicId);
      
      res.json({
        success: true,
        message: 'YarÄ±n randevu talebi onaylandÄ±',
        data: {
          faultReportId: faultReport._id,
          mechanicId: tomorrowResponse.mechanicId,
          mechanicName: mechanic ? `${mechanic.name} ${mechanic.surname}` : 'Bilinmeyen Usta',
          action: 'create_appointment',
          appointmentData: {
            faultReportId: faultReport._id,
            mechanicId: tomorrowResponse.mechanicId,
            serviceCategory: faultReport.serviceCategory,
            faultDescription: faultReport.faultDescription,
            location: faultReport.location,
            vehicleId: faultReport.vehicleId
          }
        }
      });
    } else if (action === 'reject') {
      // KullanÄ±cÄ± reddetti - ustaya bildirim gÃ¶nder
      const user = await User.findById(userId);
      const mechanic = await User.findById(tomorrowResponse.mechanicId);
      
      const rejectionNotification = {
        type: 'tomorrow_appointment_rejected',
        title: 'Randevu Talebi Reddedildi',
        message: `${user?.name} ${user?.surname} yarÄ±n randevu talebini reddetti`,
        data: {
          faultReportId: faultReport._id,
          userId: userId,
          userName: `${user?.name} ${user?.surname}`,
          action: 'rejected'
        }
      };

      sendNotificationToUser(tomorrowResponse.mechanicId.toString(), rejectionNotification);

      res.json({
        success: true,
        message: 'YarÄ±n randevu talebi reddedildi',
        data: {
          action: 'rejected'
        }
      });
    } else {
      return res.status(400).json({
        success: false,
        message: 'GeÃ§ersiz aksiyon. "accept" veya "reject" olmalÄ±'
      });
    }

  } catch (error) {
    res.status(500).json({
      success: false,
      message: 'YanÄ±t iÅŸlenirken bir hata oluÅŸtu'
    });
  }
};

// Ä°letiÅŸime geÃ§ - mesaj gÃ¶nderme
export const initiateContact = async (req: Request, res: Response) => {
  try {
    const { id } = req.params; // faultReportId
    const { message } = req.body;
    const userId = req.user?.userId;

    // Validation
    const { error } = validateContact(req.body);
    if (error) {
      return res.status(400).json({
        success: false,
        message: error.details[0].message
      });
    }

    // ArÄ±za bildirimi kontrolÃ¼
    const faultReport = await FaultReport.findById(id);
    if (!faultReport) {
      return res.status(404).json({
        success: false,
        message: 'ArÄ±za bildirimi bulunamadÄ±'
      });
    }

    // KullanÄ±cÄ± kontrolÃ¼
    if (faultReport.userId.toString() !== userId) {
      return res.status(403).json({
        success: false,
        message: 'Bu arÄ±za bildirimi size ait deÄŸil'
      });
    }

    // "Ä°letiÅŸime geÃ§" yanÄ±tÄ±nÄ± bul
    const contactResponse = faultReport.mechanicResponses.find(
      response => response.responseType === 'contact_me'
    );

    if (!contactResponse) {
      return res.status(404).json({
        success: false,
        message: 'Ä°letiÅŸim talebi bulunamadÄ±'
      });
    }

    // Usta bilgilerini al
    const mechanic = await User.findById(contactResponse.mechanicId);
    const user = await User.findById(userId);

    // Ustaya mesaj bildirimi gÃ¶nder
    const messageNotification = {
      type: 'contact_message',
      title: 'Mesaj Geldi',
      message: `${user?.name} ${user?.surname} size mesaj gÃ¶nderdi`,
      data: {
        faultReportId: faultReport._id,
        fromUserId: userId,
        fromUserName: `${user?.name} ${user?.surname}`,
        message: message,
        action: 'open_chat'
      }
    };

    sendNotificationToUser(contactResponse.mechanicId.toString(), messageNotification);

    res.json({
      success: true,
      message: 'Mesaj baÅŸarÄ±yla gÃ¶nderildi',
      data: {
        faultReportId: faultReport._id,
        mechanicId: contactResponse.mechanicId,
        mechanicName: mechanic ? `${mechanic.name} ${mechanic.surname}` : 'Bilinmeyen Usta',
        action: 'open_chat',
        chatData: {
          faultReportId: faultReport._id,
          mechanicId: contactResponse.mechanicId,
          userId: userId,
          serviceCategory: faultReport.serviceCategory,
          faultDescription: faultReport.faultDescription
        }
      }
    });

  } catch (error) {
    res.status(500).json({
      success: false,
      message: 'Mesaj gÃ¶nderilirken bir hata oluÅŸtu'
    });
  }
};

// Fiyat teklifi ver
export const submitQuote = async (req: Request, res: Response) => {
  try {
    const { id } = req.params; // URL'den faultReportId al
    const { quoteAmount, estimatedDuration, notes } = req.body;
    const mechanicId = req.user?.userId;

    // Usta kontrolÃ¼ - Ã¶nce Mechanic tablosunda ara, bulamazsan User tablosunda ara
    let mechanic = await Mechanic.findById(mechanicId);
    let userMechanic = null;
    
    if (!mechanic) {
      // Mechanic tablosunda bulunamadÄ±, User tablosunda ara
      userMechanic = await User.findById(mechanicId);
      if (!userMechanic || userMechanic.userType !== 'mechanic') {
        return res.status(404).json({
          success: false,
          message: 'Usta bulunamadÄ±'
        });
      }
    }

    // ArÄ±za bildirimi kontrolÃ¼
    const faultReport = await FaultReport.findById(id);
    if (!faultReport) {
      return res.status(404).json({
        success: false,
        message: 'ArÄ±za bildirimi bulunamadÄ±'
      });
    }

    // Zaten teklif verilmiÅŸ mi kontrol et
    const existingQuote = faultReport.quotes.find(
      quote => quote.mechanicId.toString() === mechanicId
    );

    if (existingQuote) {
      return res.status(400).json({
        success: false,
        message: 'Bu arÄ±za iÃ§in zaten teklif verdiniz'
      });
    }

    // Teklif ekle - gerÃ§ek bilgileri sakla
    const mechanicName = mechanic ? `${mechanic.name} ${mechanic.surname}` : `${userMechanic?.name} ${userMechanic?.surname}`;
    const mechanicPhone = mechanic ? mechanic.phone : userMechanic?.phone || '';
    
    faultReport.quotes.push({
      mechanicId: mechanicId as any,
      mechanicName: mechanicName || 'Bilinmeyen Usta', // GerÃ§ek isim bilgisini sakla
      mechanicPhone: mechanicPhone || '', // GerÃ§ek telefon bilgisini sakla
      quoteAmount,
      estimatedDuration,
      notes: notes || '',
      status: 'pending',
      createdAt: new Date()
    });

    faultReport.status = 'quoted';
    await faultReport.save();

    // KullanÄ±cÄ±ya bildirim gÃ¶nder
    const notification = {
      type: 'quote_received',
      title: 'Yeni Fiyat Teklifi',
      message: `${mechanicName} arÄ±zanÄ±z iÃ§in ${quoteAmount} TL teklif verdi`,
      data: {
        faultReportId: faultReport._id,
        mechanicName,
        quoteAmount,
        estimatedDuration
      }
    };

    sendNotificationToUser(faultReport.userId.toString(), notification);

    res.json({
      success: true,
      message: 'Fiyat teklifi baÅŸarÄ±yla gÃ¶nderildi',
      data: {
        quoteId: faultReport.quotes[faultReport.quotes.length - 1].mechanicId,
        quoteAmount,
        estimatedDuration
      }
    });

  } catch (error) {
    res.status(500).json({
      success: false,
      message: 'Fiyat teklifi gÃ¶nderilirken bir hata oluÅŸtu'
    });
  }
};

// Teklif seÃ§ ve randevu oluÅŸtur
export const selectQuote = async (req: Request, res: Response) => {
  try {
    const { id } = req.params; // URL'den faultReportId al
    const { quoteIndex } = req.body;
    const userId = req.user?.userId;

    const faultReport = await FaultReport.findOne({ _id: id, userId });
    if (!faultReport) {
      return res.status(404).json({
        success: false,
        message: 'ArÄ±za bildirimi bulunamadÄ±'
      });
    }

    const selectedQuote = faultReport.quotes[quoteIndex];
    if (!selectedQuote) {
      return res.status(404).json({
        success: false,
        message: 'SeÃ§ilen teklif bulunamadÄ±'
      });
    }

    // SeÃ§ilen teklifi iÅŸaretle
    faultReport.selectedQuote = {
      mechanicId: selectedQuote.mechanicId as any,
      quoteAmount: selectedQuote.quoteAmount,
      selectedAt: new Date()
    };

    faultReport.status = 'accepted';
    selectedQuote.status = 'accepted';

    // DiÄŸer teklifleri reddet
    faultReport.quotes.forEach((quote, index) => {
      if (index !== quoteIndex) {
        quote.status = 'rejected';
      }
    });

    await faultReport.save();

    // Randevu oluÅŸtur
    const appointment = new Appointment({
      userId: new mongoose.Types.ObjectId(userId),
      mechanicId: new mongoose.Types.ObjectId(selectedQuote.mechanicId),
      serviceType: faultReport.serviceCategory,
      appointmentDate: new Date(), // VarsayÄ±lan tarih, frontend'de gÃ¼ncellenecek
      timeSlot: '10:00', // VarsayÄ±lan saat, frontend'de gÃ¼ncellenecek
      description: faultReport.faultDescription,
      vehicleId: new mongoose.Types.ObjectId(faultReport.vehicleId),
      faultReportId: new mongoose.Types.ObjectId(faultReport._id as string),
      price: selectedQuote.quoteAmount, // ArÄ±za bildirimindeki fiyatÄ± kopyala
      status: 'TALEP_EDILDI',
      paymentStatus: 'pending',
      shareContactInfo: false,
      isShopAppointment: false,
      notificationSettings: {
        oneDayBefore: false,
        oneHourBefore: true,
        twoHoursBefore: false
      },
      createdAt: new Date()
    });

    await appointment.save();
    res.json({
      success: true,
      message: 'Teklif seÃ§ildi ve randevu oluÅŸturuldu',
      data: {
        appointment: {
          _id: appointment._id,
          price: appointment.price,
          status: appointment.status
        },
        selectedQuote: {
          mechanicName: selectedQuote.mechanicName, // GerÃ§ek isim bilgisini gÃ¶ster
          quoteAmount: selectedQuote.quoteAmount,
          estimatedDuration: selectedQuote.estimatedDuration
        }
      }
    });

  } catch (error) {
    res.status(500).json({
      success: false,
      message: 'Teklif seÃ§ilirken bir hata oluÅŸtu'
    });
  }
};

// UstalarÄ±n arÄ±za bildirimlerini getir
export const getMechanicFaultReports = async (req: Request, res: Response) => {
  try {
    const mechanicId = req.user?.userId;
    const { status, page = 1, limit = 10 } = req.query;

    // Ã–nce ustanÄ±n bilgilerini al - User ID ile
    const user = await User.findById(mechanicId);
    if (!user) {
      return res.status(404).json({
        success: false,
        message: 'KullanÄ±cÄ± bulunamadÄ±'
      });
    }

    // User'Ä±n email'i ile Mechanic tablosunda ara
    let mechanic = await Mechanic.findOne({ email: user.email });
    
    // EÄŸer Mechanic tablosunda yoksa, User'dan mekanik profili oluÅŸtur
    if (!mechanic) {
      // User'dan mekanik profili oluÅŸtur
      const mechanicProfile = {
        _id: user._id,
        name: user.name,
        surname: user.surname,
        email: user.email,
        phone: user.phone,
        serviceCategories: user.serviceCategories || ['repair'],
        experience: user.experience || 0,
        rating: user.rating || 0,
        ratingCount: user.ratingCount || 0,
        totalServices: user.totalServices || 0,
        isAvailable: user.isAvailable !== undefined ? user.isAvailable : true,
        location: user.location || {},
        workingHours: user.workingHours || '',
        shopName: user.shopName || '',
        bio: user.bio || '',
        avatar: user.avatar,
        cover: user.cover,
        vehicleBrands: user.carBrands || [],
        engineTypes: user.engineTypes || [],
        transmissionTypes: user.transmissionTypes || [],
        customBrands: user.customBrands || [],
        supportedBrands: user.carBrands || ['Genel'],
        createdAt: user.createdAt
      };
      
      mechanic = mechanicProfile as any;
      
    }

    // UstanÄ±n hizmet kategorileri ve desteklediÄŸi markalar
    // EÄŸer mechanic objesi oluÅŸturulduysa, user.serviceCategories'i kullan
    const mechanicServiceCategories = mechanic?.serviceCategories || user.serviceCategories || ['repair'];
    const mechanicSupportedBrands = mechanic?.supportedBrands || [];

    // UstanÄ±n ServiceCategory'lerine gÃ¶re hangi fault kategorilerini gÃ¶receÄŸini belirle
    // FAULT_CATEGORY_TO_SERVICE_CATEGORY mapping'i kullan
    const allowedFaultCategories: string[] = [];
    
    Object.entries(FAULT_CATEGORY_TO_SERVICE_CATEGORY).forEach(([faultCat, serviceCat]) => {
      if (mechanicServiceCategories.includes(serviceCat)) {
        allowedFaultCategories.push(faultCat);
      }
    });

    // Temel sorgu - ustanÄ±n hizmet kategorisine uygun arÄ±za bildirimleri
    const query: any = {
      serviceCategory: { $in: allowedFaultCategories },
      // UstanÄ±n "mÃ¼sait deÄŸilim" dediÄŸi arÄ±za bildirimlerini hariÃ§ tut
      'mechanicResponses': {
        $not: {
          $elemMatch: {
            mechanicId: mechanicId,
            responseType: 'not_available'
          }
        }
      },
      // Accepted durumundaki arÄ±za bildirimleri sadece seÃ§ili usta tarafÄ±ndan gÃ¶rÃ¼lmeli
      $or: [
        { status: { $ne: 'accepted' } },
        { 'selectedQuote.mechanicId': mechanicId }
      ]
    };

    // Status filtreleme
    if (status) {
      if (status === 'pending') {
        // Pending: Bekleyen arÄ±za bildirimleri
        query.status = 'pending';
      } else if (status === 'quoted') {
        // Quoted: UstanÄ±n teklif verdiÄŸi arÄ±za bildirimleri
        query.$and = [
          { status: 'quoted' },
          { 'quotes.mechanicId': mechanicId }
        ];
      } else if (status === 'accepted') {
        // Accepted: UstanÄ±n teklifi kabul edilen arÄ±za bildirimleri
        query.$and = [
          { status: 'accepted' },
          { 'selectedQuote.mechanicId': mechanicId }
        ];
      } else {
        query.status = status;
      }
    }

    // ArÄ±za bildirimlerini getir
    const faultReports = await FaultReport.find(query)
      .populate('userId', 'name surname phone')
      .populate('vehicleId', 'brand modelName plateNumber year')
      .sort({ createdAt: -1 })
      .limit(Number(limit) * 1)
      .skip((Number(page) - 1) * Number(limit));

    const total = await FaultReport.countDocuments(query);

    res.json({
      success: true,
      data: faultReports,
      pagination: {
        current: Number(page),
        pages: Math.ceil(total / Number(limit)),
        total
      }
    });

  } catch (error) {
    res.status(500).json({
      success: false,
      message: 'ArÄ±za bildirimleri getirilirken bir hata oluÅŸtu'
    });
  }
};

// YardÄ±mcÄ± fonksiyon: Ã‡evredeki uygun ustalarÄ± bul
async function findNearbyMechanics(
  coordinates: [number, number] | undefined,
  serviceCategory: string,
  vehicleBrand: string,
  userCity?: string
) {
  try {
    // Fault category'yi ServiceCategory enum'una Ã§evir
    const normalizedServiceCategory = getFaultReportServiceCategory(serviceCategory);
    
    // O kategorinin tÃ¼m query deÄŸerlerini al (enum deÄŸeri + TÃ¼rkÃ§e alternatifleri)
    const matchingCategories = getCategoryQueryValues(normalizedServiceCategory);

    // Ã–nce Mechanic modelinde ara
    let mechanics = await Mechanic.find({
      isAvailable: true,
      serviceCategories: { $in: matchingCategories },
      $or: [
        { supportedBrands: { $in: [vehicleBrand] } },
        { supportedBrands: { $in: ['Genel', 'TÃ¼m Markalar', 'TÃ¼mÃ¼'] } },
        { vehicleBrands: { $in: [vehicleBrand] } },
        { vehicleBrands: { $in: ['Genel', 'TÃ¼m Markalar', 'TÃ¼mÃ¼'] } }
      ]
    }).lean();

    // User modelinde de ara (rektefe-us uygulamasÄ±ndan gelen ustalar)
    const userMechanics = await User.find({
      userType: 'mechanic',
      isAvailable: true,
      serviceCategories: { $in: matchingCategories },
      $or: [
        { supportedBrands: { $in: [vehicleBrand] } },
        { supportedBrands: { $in: ['Genel', 'TÃ¼m Markalar', 'TÃ¼mÃ¼'] } },
        { vehicleBrands: { $in: [vehicleBrand] } },
        { vehicleBrands: { $in: ['Genel', 'TÃ¼m Markalar', 'TÃ¼mÃ¼'] } }
      ]
    }).lean();

    // User verilerini Mechanic formatÄ±na Ã§evir
    const formattedUserMechanics = userMechanics.map(user => ({
      _id: user._id,
      name: user.name,
      surname: user.surname,
      email: user.email,
      phone: user.phone || '',
      // location kaldÄ±rÄ±ldÄ±
      serviceCategories: user.serviceCategories || ['Genel BakÄ±m'],
      supportedBrands: (user as any).supportedBrands || user.vehicleBrands || ['Genel'],
      isAvailable: user.isAvailable || true
    }));

    // TÃ¼m ustalarÄ± birleÅŸtir
    const allMechanics = [...mechanics, ...formattedUserMechanics];

    // Konum sÄ±ralamasÄ± kaldÄ±rÄ±ldÄ± - sadece hizmet kategorisine gÃ¶re dÃ¶ndÃ¼r
    return allMechanics.slice(0, 20); // En fazla 20 usta

  } catch (error) {
    return [];
  }
}

// Mesafe hesaplama fonksiyonu kaldÄ±rÄ±ldÄ± - artÄ±k kullanÄ±lmÄ±yor

// Ã–deme oluÅŸturma
export const createPayment = async (req: Request, res: Response) => {
  try {
    const { faultReportId } = req.params;
    const { paymentMethod = 'credit_card' } = req.body;
    const userId = (req as any).user?.userId;

    if (!userId) {
      return res.status(401).json({
        success: false,
        message: 'KullanÄ±cÄ± doÄŸrulanamadÄ±'
      });
    }

    // ArÄ±za bildirimini bul
    const faultReport = await FaultReport.findById(faultReportId)
      .populate('userId', 'name surname email')
      .populate('selectedQuote.mechanicId', 'name surname email phone');

    if (!faultReport) {
      return res.status(404).json({
        success: false,
        message: 'ArÄ±za bildirimi bulunamadÄ±'
      });
    }

    // Sadece arÄ±za bildirimi sahibi Ã¶deme yapabilir
    if (faultReport.userId._id.toString() !== userId) {
      return res.status(403).json({
        success: false,
        message: 'Bu arÄ±za bildirimi iÃ§in Ã¶deme yapma yetkiniz yok'
      });
    }

    // Sadece accepted durumundaki arÄ±za bildirimleri iÃ§in Ã¶deme yapÄ±labilir
    if (faultReport.status !== 'accepted') {
      return res.status(400).json({
        success: false,
        message: 'Bu arÄ±za bildirimi iÃ§in Ã¶deme yapÄ±lamaz'
      });
    }

    // SeÃ§ili teklif yoksa hata
    if (!faultReport.selectedQuote) {
      return res.status(400).json({
        success: false,
        message: 'SeÃ§ili teklif bulunamadÄ±'
      });
    }

    // Ã–deme zaten yapÄ±lmÄ±ÅŸsa hata
    if (faultReport.payment && faultReport.payment.status === 'completed') {
      return res.status(400).json({
        success: false,
        message: 'Bu arÄ±za bildirimi iÃ§in Ã¶deme zaten yapÄ±lmÄ±ÅŸ'
      });
    }

    // Ã–deme bilgilerini gÃ¼ncelle
    faultReport.payment = {
      amount: faultReport.selectedQuote.quoteAmount,
      status: 'pending',
      paymentMethod,
      paymentDate: new Date()
    };

    // Durumu payment_pending yap
    faultReport.status = 'payment_pending';

    await faultReport.save();

    // Ustaya bildirim gÃ¶nder
    const notification = {
      type: 'payment_pending',
      title: 'Ã–deme Bekleniyor',
      message: `${(faultReport.userId as any).name} ${(faultReport.userId as any).surname} Ã¶deme yapmaya hazÄ±rlanÄ±yor`,
      data: {
        faultReportId: faultReport._id,
        amount: faultReport.selectedQuote?.quoteAmount || 0,
        customerName: `${(faultReport.userId as any).name} ${(faultReport.userId as any).surname}`
      }
    };

    sendNotificationToUser(faultReport.selectedQuote?.mechanicId._id.toString() || '', notification);

    res.json({
      success: true,
      message: 'Ã–deme oluÅŸturuldu',
      data: {
        faultReportId: faultReport._id,
        amount: faultReport.selectedQuote?.quoteAmount || 0,
        paymentMethod,
        status: 'payment_pending'
      }
    });

  } catch (error) {
    res.status(500).json({
      success: false,
      message: 'Ã–deme oluÅŸturulurken bir hata oluÅŸtu'
    });
  }
};

// Ã–deme onaylama
export const confirmPayment = async (req: Request, res: Response) => {
  try {
    const { faultReportId } = req.params;
    const { transactionId } = req.body;
    const userId = (req as any).user?.userId;

    if (!userId) {
      return res.status(401).json({
        success: false,
        message: 'KullanÄ±cÄ± doÄŸrulanamadÄ±'
      });
    }

    // ArÄ±za bildirimini bul
    const faultReport = await FaultReport.findById(faultReportId)
      .populate('userId', 'name surname email')
      .populate('selectedQuote.mechanicId', 'name surname email phone');

    if (!faultReport) {
      return res.status(404).json({
        success: false,
        message: 'ArÄ±za bildirimi bulunamadÄ±'
      });
    }

    // Sadece arÄ±za bildirimi sahibi Ã¶deme onaylayabilir
    if (faultReport.userId._id.toString() !== userId) {
      return res.status(403).json({
        success: false,
        message: 'Bu arÄ±za bildirimi iÃ§in Ã¶deme onaylama yetkiniz yok'
      });
    }

    // Sadece payment_pending durumundaki arÄ±za bildirimleri iÃ§in Ã¶deme onaylanabilir
    if (faultReport.status !== 'payment_pending') {
      return res.status(400).json({
        success: false,
        message: 'Bu arÄ±za bildirimi iÃ§in Ã¶deme onaylanamaz'
      });
    }

    // Ã–deme bilgilerini gÃ¼ncelle
    if (faultReport.payment) {
      faultReport.payment.status = 'completed';
      faultReport.payment.transactionId = transactionId;
      faultReport.payment.paymentDate = new Date();
    }

    // Durumu paid yap
    faultReport.status = 'paid';

    await faultReport.save();

    // TefePuan kazandÄ±r
    try {
      const tefePointResult = await TefePointService.processPaymentTefePoints({
        userId: faultReport.userId._id.toString(),
        amount: faultReport.selectedQuote?.quoteAmount || 0,
        paymentType: 'fault_report',
        serviceCategory: 'maintenance', // ArÄ±za bildirimi iÃ§in genel bakÄ±m kategorisi
        description: `ArÄ±za bildirimi Ã¶demesi - ${(faultReport.selectedQuote?.mechanicId as any).name}`,
        serviceId: (faultReport._id as any).toString()
      });

      if (tefePointResult.success && tefePointResult.earnedPoints) {
        }
    } catch (tefeError) {
      // TefePuan hatasÄ± Ã¶deme iÅŸlemini durdurmaz
    }

    // Ustaya bildirim gÃ¶nder
    const notification = {
      type: 'payment_completed',
      title: 'Ã–deme TamamlandÄ±',
      message: `${(faultReport.userId as any).name} ${(faultReport.userId as any).surname} Ã¶demeyi tamamladÄ±. Ä°ÅŸe baÅŸlayabilirsiniz.`,
      data: {
        faultReportId: faultReport._id,
        amount: faultReport.selectedQuote?.quoteAmount || 0,
        customerName: `${(faultReport.userId as any).name} ${(faultReport.userId as any).surname}`,
        transactionId
      }
    };

    sendNotificationToUser(faultReport.selectedQuote?.mechanicId._id.toString() || '', notification);

    res.json({
      success: true,
      message: 'Ã–deme baÅŸarÄ±yla tamamlandÄ±',
      data: {
        faultReportId: faultReport._id,
        amount: faultReport.selectedQuote?.quoteAmount || 0,
        status: 'paid',
        transactionId
      }
    });

  } catch (error) {
    res.status(500).json({
      success: false,
      message: 'Ã–deme onaylanÄ±rken bir hata oluÅŸtu'
    });
  }
};

// Usta iÅŸi finalize etme
export const finalizeWork = async (req: Request, res: Response) => {
  try {
    const { faultReportId } = req.params;
    const { notes } = req.body;
    const mechanicId = (req as any).user?.userId;

    if (!mechanicId) {
      return res.status(401).json({
        success: false,
        message: 'Usta doÄŸrulanamadÄ±'
      });
    }

    // ArÄ±za bildirimini bul
    const faultReport = await FaultReport.findById(faultReportId)
      .populate('userId', 'name surname email')
      .populate('selectedQuote.mechanicId', 'name surname email phone');

    if (!faultReport) {
      return res.status(404).json({
        success: false,
        message: 'ArÄ±za bildirimi bulunamadÄ±'
      });
    }

    // Sadece seÃ§ili usta finalize edebilir
    if (faultReport.selectedQuote?.mechanicId._id.toString() !== mechanicId) {
      return res.status(403).json({
        success: false,
        message: 'Bu arÄ±za bildirimi iÃ§in iÅŸi bitirme yetkiniz yok'
      });
    }

    // Sadece paid durumundaki arÄ±za bildirimleri finalize edilebilir
    if (faultReport.status !== 'paid') {
      return res.status(400).json({
        success: false,
        message: 'Bu arÄ±za bildirimi iÃ§in iÅŸ bitirilemez'
      });
    }

    // Durumu completed yap
    faultReport.status = 'completed';

    // Usta notlarÄ± ekle (eÄŸer varsa)
    if (notes) {
      faultReport.faultDescription += `\n\nUsta NotlarÄ±: ${notes}`;
    }

    await faultReport.save();

    // MÃ¼ÅŸteriye bildirim gÃ¶nder
    const notification = {
      type: 'work_completed',
      title: 'Ä°ÅŸ TamamlandÄ±',
      message: `${(faultReport.selectedQuote?.mechanicId as any).name} ${(faultReport.selectedQuote?.mechanicId as any).surname} Usta iÅŸinizi tamamladÄ±`,
      data: {
        faultReportId: faultReport._id,
        mechanicName: `${(faultReport.selectedQuote?.mechanicId as any).name} ${(faultReport.selectedQuote?.mechanicId as any).surname}`,
        amount: faultReport.selectedQuote?.quoteAmount
      }
    };

    sendNotificationToUser(faultReport.userId._id.toString(), notification);

    res.json({
      success: true,
      message: 'Ä°ÅŸ baÅŸarÄ±yla tamamlandÄ±',
      data: {
        faultReportId: faultReport._id,
        status: 'completed',
        completedAt: new Date()
      }
    });

  } catch (error) {
    res.status(500).json({
      success: false,
      message: 'Ä°ÅŸ finalize edilirken bir hata oluÅŸtu'
    });
  }
};
